"""
문제 : 섬의 개수
1을 육지로, 0을 물로 가정한 2d 그리드 맵이 주어졌을 때, 섬의 개수를 구하여라.
"""
from typing import List
"""
해설 : 
그래프 형태는 아니더라도 인접행렬도 DFS나 BFS로 풀 수 있다.
페이스북 및 해외 기업에서 면접 시 자주 쓰이는 유명한 문제 
동서남북이 연결된 그래프로 가정하고 동일 한 형태로 처리 가능 
네 방향 각각 DFS 재귀를 이용해 탐색을 끝마치면 1이 증가하는 형태 
//////////////////////////////////////////////////////////
행렬 입력값인 grid 의 행 열 단위로 육지 1인 곳을 찾아 진행 
육지를 발견하면 그때부터 self.dfs() 호출해 탐색 
여기서 육지(1)를 발견하면 네방향으로 dfs탐색 시작하고 탐색을 끝낸 노드는 0이나 #으로 바꾼다
보통 방문한 노드를 저장하는 리스트를 만드는 경우도 있는데 시간복잡도 O(N)이 소모되므로 비효율적인데다
공간복잡도도 높아지기 마련 .... 그래서 마킹만 해둔다.  
"""
grid = [
    ["1", "1", "1", "1", "0"],
    ["1", "1", "0", "1", "0"],
    ["1", "1", "0", "0", "0"],
    ["0", "0", "0", "0", "0"]
]


def numIslands(grid: List[List[str]]) -> int:
    # self 쓰지 않고 지저분한 코드 정리 => 중첩함수 사용
    # 부모함수에서 선언한  함수도 유용하게 사용
    # 원래는 global사용
    def dfs(i, j):
        # 더 이상 땅이 아닌 경우 종료
        if i < 0 or i >= len(grid) or \
                j < 0 or j >= len(grid[0]) or \
                grid[i][j] != '1':
            return
        grid[i][j] = 0

        # 동서남북 탐색
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                dfs(i, j)
                # 모든 육지 탐색 후 카운트 1 증가
                count += 1
    return count


print(numIslands(grid))
