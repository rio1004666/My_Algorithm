import collections
from typing import List

n = 100
courses = [[1, 0], [2, 0], [2, 1], [3, 1], [3, 2], [4, 2], [4, 3], [5, 3], [5, 4], [6, 4], [6, 5], [7, 5], [7, 6],
           [8, 6], [8, 7], [9, 7], [9, 8], [10, 8], [10, 9], [11, 9], [11, 10], [12, 10], [12, 11], [13, 11], [13, 12],
           [14, 12], [14, 13], [15, 13], [15, 14], [16, 14], [16, 15], [17, 15], [17, 16], [18, 16], [18, 17], [19, 17],
           [19, 18], [20, 18], [20, 19], [21, 19], [21, 20], [22, 20], [22, 21], [23, 21], [23, 22], [24, 22], [24, 23],
           [25, 23], [25, 24], [26, 24], [26, 25], [27, 25], [27, 26], [28, 26], [28, 27], [29, 27], [29, 28], [30, 28],
           [30, 29], [31, 29], [31, 30], [32, 30], [32, 31], [33, 31], [33, 32], [34, 32], [34, 33], [35, 33], [35, 34],
           [36, 34], [36, 35], [37, 35], [37, 36], [38, 36], [38, 37], [39, 37], [39, 38], [40, 38], [40, 39], [41, 39],
           [41, 40], [42, 40], [42, 41], [43, 41], [43, 42], [44, 42], [44, 43], [45, 43], [45, 44], [46, 44], [46, 45],
           [47, 45], [47, 46], [48, 46], [48, 47], [49, 47], [49, 48], [50, 48], [50, 49], [51, 49], [51, 50], [52, 50],
           [52, 51], [53, 51], [53, 52], [54, 52], [54, 53], [55, 53], [55, 54], [56, 54], [56, 55], [57, 55], [57, 56],
           [58, 56], [58, 57], [59, 57], [59, 58], [60, 58], [60, 59], [61, 59], [61, 60], [62, 60], [62, 61], [63, 61],
           [63, 62], [64, 62], [64, 63], [65, 63], [65, 64], [66, 64], [66, 65], [67, 65], [67, 66], [68, 66], [68, 67],
           [69, 67], [69, 68], [70, 68], [70, 69], [71, 69], [71, 70], [72, 70], [72, 71], [73, 71], [73, 72], [74, 72],
           [74, 73], [75, 73], [75, 74], [76, 74], [76, 75], [77, 75], [77, 76], [78, 76], [78, 77], [79, 77], [79, 78],
           [80, 78], [80, 79], [81, 79], [81, 80], [82, 80], [82, 81], [83, 81], [83, 82], [84, 82], [84, 83], [85, 83],
           [85, 84], [86, 84], [86, 85], [87, 85], [87, 86], [88, 86], [88, 87], [89, 87], [89, 88], [90, 88], [90, 89],
           [91, 89], [91, 90], [92, 90], [92, 91], [93, 91], [93, 92], [94, 92], [94, 93], [95, 93], [95, 94], [96, 94],
           [96, 95], [97, 95], [97, 96], [98, 96], [98, 97], [99, 97]]


# 이 알고리즘은 가지치기를 안해서 시간초과난다
# 이미 방문한노드는 완료한 코스이므로 가지치기 해버린다.
def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:
    graph = collections.defaultdict(list)
    # 그래프 구성
    for x, y in prerequisites:
        graph[x].append(y)
    # set자료구조로 이미 방문했던 곳을 저장해두는 것이 핵심이다.
    # 1을 방문하기위해 0을 방문해야하니 0으로 간다 그리고 0을 방문하기 위해 1을 방문해야하는데 1을 방문하기위해서는 0을 방문해야하므로 순환구조이다.
    # 1부터 시작해서 쭉쭉 시작해서 이미 방문한 노드를 만난다면 순환구조이고 계속 새로운 노드라면 순환구조가 아니다.
    traced = set()

    def dfs(i):
        if i in traced:
            return False
        traced.add(i)
        for y in graph[i]:
            if not dfs(y):
                return False
        traced.remove(i)
        return True

    for x in list(graph):
        if not dfs(x):
            return False
    return True


# print(canFinish(3, [[0, 1], [1, 2], [0, 2]]))
# print(canFinish(n, courses))


def canFinish2(courseNum: int, prerequisites: List[List[int]]) -> bool:
    graph = collections.defaultdict(list)

    for x, y in prerequisites:
        graph[x].append(y)
    # for key,value in graph.items():
    #     print(key, value)
    traced = set()
    # 가지치기로 한번 방문한 노드는 더이상 방문하지 않으므로서 효율적인 알고리즘 구현이 될 수 있다!!!!!!
    visited = set()

    def dfs(node):
        if node in traced:
            return False
        if node in visited:
            return True
        traced.add(node)
        # 0방문 -> 1방문 -> 2방문하는 순간 graph[2]는 원래 없던 키에 대한 접근이다.
        # defaultdict에 의해 graph[2] = [] 가 생성되면서 graph 딕셔너리에 변동이 생긴다.
        # 그러면 for 문은 원래 고정된 길이에 대한 접근만 허용하는데 크기가 변동되었으므로 에러가 생긴다.
        # defaultdict를 사용하지 않으면 또 없는키에 대한 널값처리를 못하므로 에러가 생긴다 그러므로
        # graph를 고정된 길이로 감싸줘야한다 즉 list화 시킨다. 그러면
        # graph[0]과 graph[1] 로 고정되고 2번노드에 접근해서 default한다하더라도 새로운 딕셔너리가 새로운 list로 변경되었으므로 크기 변동이 없고 그대로
        # 반복문을 진행 할 수 있다.
        # 파이썬의 이런 컴파일러 특징을 잘 이해해야 테스트에서 당황하지 않고 할 수 있다.
        for next_node in graph[node]:
            if not dfs(next_node):
                return False
        traced.remove(node)
        visited.add(node)
        return True

    print(list(graph))
    for node in list(graph):
        if not dfs(node):
            return False
    return True


print(canFinish2(n, courses))
# print(canFinish2(2,  [[1, 0], [0, 1]]))
